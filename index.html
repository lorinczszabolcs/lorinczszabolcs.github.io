<!DOCTYPE html>
<html lang="en">
	<head>
		<title>LÅ‘rincz Szabolcs-Botond - Personal Website</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

	</head>
	<body>

		<script src="js/three.js"></script>
		<script src="js/GLTFLoader.js"></script>

		<script src="js/WebGL.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<div id="page-content" style="width:100%;align-self: center;">
			<!-- Page Content -->
			<!-- <div class="text-center p-4" id="hero-content" style="position: absolute; top:50%; left:50%;transform: translateX(-50%) translateY(-50%); background-color: rgba(33, 225, 12, 0.2); opacity:50%;">
				<h1 class="text-white">Awesome webpage</h1>
				<p class="text-white">under construction</p>
			</div> -->
			<div class="vignette"></div>
			<div class="glitch"></div>
			<!-- <div class="popup"><div class="text"></div></div> -->
			<div id="animation-content"></div>
		</div>

		
		

		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float scale;
			void main() {
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = scale * ( 150.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			void main() {
				if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;
				gl_FragColor = vec4(256.0/256.0,  // R
				256.0/256.0,  // G
				256.0/256.0,// B
                      1.0); // A
			}
		</script>

		<script>
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}
			var SEPARATION = 100, AMOUNTX = 150, AMOUNTY = 150;
			var container, stats;
			var camera, scene, renderer;
			var particles, count = 0;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			const target = new THREE.Vector2();

			var loader;
			var modelgeom, modelgeom2, modelgeom3;
			var objects = [];

			init();
			animate();
			function init() {
				container = document.getElementById("animation-content");
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;
				camera.rotation.order = 'YXZ';
				scene = new THREE.Scene();
				
				var numParticles = AMOUNTX * AMOUNTY;
				var positions = new Float32Array( numParticles * 3 );
				var scales = new Float32Array( numParticles );
				var i = 0, j = 0;
				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // y
						positions[ i + 2 ] = -200; // z
						scales[ j ] = 1;
						i += 3;
						j ++;
					}
				}
				var geometry = new THREE.BufferGeometry();
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );
				var material = new THREE.ShaderMaterial( {
					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent
				} );
				//
				particles = new THREE.Points( geometry, material );
				scene.add( particles );
				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				stats = new Stats();
				// container.appendChild( stats.dom );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				//
				window.addEventListener( 'resize', onWindowResize, false );

				var light = new THREE.DirectionalLight("#fff", 1.5);
				var light2 = new THREE.DirectionalLight("#fff", 1.5);
				var ambient = new THREE.AmbientLight("#fff");
				light.position.set( 0, 200, 0 );
				light2.position.set( 0, -200, 0 );
				scene.add(light);
				scene.add(light2);
				scene.add(ambient);

				//hemi light
				hemi = new THREE.HemisphereLight(0xbbbbbb, 0x660066);
				scene.add(hemi);   

				// loader = new THREE.GLTFLoader();
				// loader.load( 'models/saturn/scene.gltf', function ( gltf ) {
				// 	modelgeom = gltf.scene;
				// 	modelgeom.scale.set( 20, 20, 20 );
				// 	modelgeom.position.set(-500, 0, 0);
				// 	scene.add(modelgeom);
				// 	scene.traverse(function(children){
				// 		if (children.name != "Circle") {
				// 			objects.push(children);
				// 		}
				// 	});	

				// 	raycaster = new THREE.Raycaster();
				// 	mouse = new THREE.Vector2();
					
				// 	//add event listener for mouse and calls function when activated
				// 	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				// 	document.addEventListener( 'touchstart', onDocumentTouchStart, false ); 
					
				// 	$( ".text" ).empty();
				// 	$( ".popup" ).hide();
				// });

				// loader.load( 'models/brain.gltf', function ( gltf ) {
				// 	modelgeom2 = gltf.scene;
				// 	modelgeom2.scale.set( 30, 30, 30 );
				// 	modelgeom2.position.set(250, 200, 200);
				// 	scene.add(modelgeom2);
				// 	scene.traverse(function(children){
				// 		objects.push(children);
				// 	});	
				// });

				// loader.load( 'models/visualize3.gltf', function ( gltf ) {
				// 	console.log(gltf);
				// 	modelgeom3 = gltf.scene;
				// 	modelgeom3.scale.set( 12, 12, 12 );
				// 	modelgeom3.position.set(-250, 200, 200);
				// 	scene.add(modelgeom3);
				// 	scene.traverse(function(children){
				// 		objects.push(children);
				// 	});	
				// });
			}
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//
			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}
			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

					onDocumentMouseDown(event);
				}
			}
			function onDocumentTouchMove( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				var color = (Math.random() * 0xffffff);

				if ( intersects.length > 0 ) {
					
					this.temp = intersects[ 0 ].object.material.color.getHexString();
					this.name = intersects[ 0 ].object.name;
					console.log(intersects[0].object);
					
					$( ".text" ).empty();
					$( ".popup" ).append( "<div class='text'><p>This is the color <strong>#" + this.temp + "</strong> and the name assigned in Blender is <strong>" + this.name  + "</strong></p></div>" );
					$(".popup").show();
					
				}
				else {
					$( ".text" ).empty();
					$( ".popup" ).hide();
				}
			}
			//
			function animate() {

				requestAnimationFrame( animate );
				render( scene, camera );
				
				stats.update();
			}
			function render() {
				target.x = ( 1 - mouseX ) * 0.001;
				target.y = ( 1 - mouseY ) * 0.001;
				
				camera.rotation.x += 0.025 * ( target.y - camera.rotation.x );
				camera.rotation.y += 0.025 * ( target.x - camera.rotation.y );
				// modelgeom.rotation.x += 0.05 * ( target.y - camera.rotation.x ) + 0.0035;
				// modelgeom.rotation.y += 0.05 * ( target.x - camera.rotation.y ) - 0.0035;
				// modelgeom2.rotation.x += 0.05 * ( target.y - camera.rotation.x ) + 0.0035;
				// modelgeom2.rotation.y += 0.05 * ( target.x - camera.rotation.y ) - 0.0035;
				// modelgeom3.rotation.x += 0.05 * ( target.y - camera.rotation.x ) + 0.0035;
				// modelgeom3.rotation.y += 0.05 * ( target.x - camera.rotation.y ) - 0.0035;

				var positions = particles.geometry.attributes.position.array;
				var scales = particles.geometry.attributes.scale.array;
				var i = 0, j = 0;
				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
						positions[ i + 2 ] = -200 + ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
										( Math.sin( ( iy + count ) * 0.5 ) * 50 );
						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 8 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 8;
						i += 3;
						j ++;
					}
				}
				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;
				renderer.render( scene, camera );
				count += 0.025;
			}

			// from THREE.js examples
			function generateSprite() {
				var canvas = document.createElement('canvas');
				canvas.width = 16;
				canvas.height = 16;
				var context = canvas.getContext('2d');
				var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
				gradient.addColorStop(0, 'rgba(255,255,255,1)');
				gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
				gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
				gradient.addColorStop(1, 'rgba(0,0,0,1)');
				context.fillStyle = gradient;
				context.fillRect(0, 0, canvas.width, canvas.height);
				var texture = new THREE.Texture(canvas);
				texture.needsUpdate = true;
				return texture;
			}
			function createPointCloud(geom) {
				var material = new THREE.PointsMaterial({
					color: 0xffffff,
					size: 3,
					transparent: false,
					blending: THREE.AdditiveBlending,
					map: generateSprite()
				});
				var cloud = new THREE.Points(geom, material);
				cloud.sortParticles = true;
				return cloud;
			}
		</script>

		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
	</body>
</html>